<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>synthesizer-output-files</title>
  <style>
    body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    h2 { color: #34495e; margin-top: 30px; border-bottom: 2px solid #ecf0f1; padding-bottom: 8px; }
    h3 { color: #7f8c8d; margin-top: 20px; }
    code { font-family: 'Monaco', 'Courier New', monospace; font-size: 0.9em; }
    pre { line-height: 1.4; }
    a { color: #3498db; text-decoration: none; }
    a:hover { text-decoration: underline; }
    img { display: block; margin: 20px 0; border: 1px solid #ddd; border-radius: 5px; }
    ul { margin: 15px 0; padding-left: 30px; }
    li { margin: 8px 0; }
  </style>
</head>
<body>
  <h1>Synthesizer: Output Files Reference</h1>

<p>This document explains how to read and interpret the three output files generated by <a href="synthesizer-terminology.md#synthesizer">Synthesizer</a>: <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">permutation.json</code>, <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">instance.json</code>, and <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">placementVariables.json</code>.</p>

<p>---</p>

<h2>Overview</h2>

<p>After processing a transaction, Synthesizer generates three JSON files that contain all the information needed for proof generation:</p>

<p>| File                      | Purpose                              |<br>| ------------------------- | ------------------------------------ |<br>| <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">permutation.json</code>        | Circuit topology (wire connections)  |<br>| <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">instance.json</code>           | Public/private I/O witness           |<br>| <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">placementVariables.json</code> | Complete witness for all subcircuits |</p>

<p>---</p>

<h2>1. permutation.json</h2>

<h3>Purpose</h3>

<p>Describes <strong>how <a href="synthesizer-terminology.md#wire">wires</a> are connected</strong> between <a href="synthesizer-terminology.md#placement">placements</a>. This defines the circuit's topology as a Directed Acyclic Graph (DAG).</p>

<h3>Structure</h3>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>[
  {
    &quot;row&quot;: 100,
    &quot;col&quot;: 2,
    &quot;X&quot;: 619,
    &quot;Y&quot;: 26
  },
  {
    &quot;row&quot;: 619,
    &quot;col&quot;: 26,
    &quot;X&quot;: 619,
    &quot;Y&quot;: 27
  },
  {
    &quot;row&quot;: 619,
    &quot;col&quot;: 27,
    &quot;X&quot;: 100,
    &quot;Y&quot;: 2
  },
  // ... more entries
]
</code></pre>

<h3>Reading the Format</h3>

<p><strong>Key Pattern</strong>: Entries come in <strong>N-entry cycles</strong> (where N = number of wires sharing the same value):</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>Example: 3-entry cycle (when 3 wires share the same value)
Entry 1: (row, col) → (X, Y)    // Wire 1 → Wire 2
Entry 2: (X, Y) → (X&#039;, Y&#039;)      // Wire 2 → Wire 3
Entry 3: (X&#039;, Y&#039;) → (row, col)  // Wire 3 → Wire 1 (cycle back)
</code></pre>

<p><strong>Important</strong>: The cycle size depends on how many placements use the same wire value:</p>

<ul><li>2 wires sharing a value → 2-entry cycle</li>
<li>3 wires sharing a value → 3-entry cycle</li>
<li>N wires sharing a value → N-entry cycle</li>

<p><strong>Coordinate System</strong>:</p>

<p><li><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">(row, col)</code> = Wire position in format <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">(wireIndex, placementId)</code></li><br><li><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">row</code> = Wire index within a <a href="synthesizer-terminology.md#placement">placement</a></li><br><li><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">col</code> = Placement ID (<a href="synthesizer-terminology.md#subcircuit">subcircuit</a> instance number)</li></p>

<p><strong>Example: 3-Entry Cycle</strong></p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>// Wire 100 is shared by 3 placements: (100,2), (619,26), (619,27)
{ &quot;row&quot;: 100, &quot;col&quot;: 2, &quot;X&quot;: 619, &quot;Y&quot;: 26 },    // Wire 1 → Wire 2
{ &quot;row&quot;: 619, &quot;col&quot;: 26, &quot;X&quot;: 619, &quot;Y&quot;: 27 },   // Wire 2 → Wire 3
{ &quot;row&quot;: 619, &quot;col&quot;: 27, &quot;X&quot;: 100, &quot;Y&quot;: 2 }     // Wire 3 → Wire 1
</code></pre>

<p>Interpretation:</p>

<p>1. <strong>Placement 2</strong> (<a href="synthesizer-terminology.md#prv-in-and-prv-out">PRV_IN</a> buffer), <strong><a href="synthesizer-terminology.md#wire">wire</a> 100</strong> outputs a value<br>2. This value is used by <strong>Placement 26</strong> (wire 619) and <strong>Placement 27</strong> (wire 619)<br>3. The 3-entry cycle ensures: <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">Placement2[100] == Placement26[619] == Placement27[619]</code></p>

<h3>How Placements are Grouped (Code-Based)</h3>

<p>The grouping of placements into N-entry cycles happens in two main steps during finalization:</p>

<p><strong>Step 1: Build Permutation Groups</strong> (<code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">_buildPermGroup()</code>)</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>// permutation.ts:441-562
private _buildPermGroup(): Map&lt;string, boolean&gt;[] {
  let permGroup: Map&lt;string, boolean&gt;[] = [];

<p>  // 1. Create groups from output wires (representatives)<br>  for (const placeId of this.placements.keys()) {<br>    const thisPlacement = this.placements.get(placeId)!;<br>    for (let i = 0; i &lt; thisSubcircuitInfo.NOutWires; i++) {<br>      const placementWireId = {<br>        placementId: placeId,           // e.g., 2 (PRV_IN)<br>        globalWireId: globalWireId      // e.g., 100<br>      };<br>      const groupEntry = new Map();<br>      groupEntry.set(JSON.stringify(placementWireId), true);<br>      permGroup.push(groupEntry);  // New group created<br>    }<br>  }</p>

<p>  // 2. Add input wires to their parent&#039;s group<br>  for (const thisPlacementId of this.placements.keys()) {<br>    const thisPlacement = this.placements.get(thisPlacementId)!;<br>    for (let i = 0; i &lt; thisSubcircuitInfo.NInWires; i++) {<br>      const thisInPt = thisPlacement.inPts[i];</p>

<p>      if (thisInPt.source !== thisPlacementId) {<br>        // Find parent placement<br>        const pointedPlacementId = thisInPt.source!;  // e.g., 2<br>        const pointedOutputId = /<em> find matching output wire </em>/;</p>

<p>        // Add this wire to parent&#039;s group<br>        searchInsert(pointedPlacementWireId, thisPlacementWireId, permGroup);<br>      }<br>    }<br>  }</p>

<p>  return permGroup;  // Groups of wires with same value<br>}<br></code></pre></p>

<p><strong>Result</strong>: Groups like <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">[{placementId:2, wireId:100}, {placementId:26, wireId:619}, {placementId:27, wireId:619}]</code></p>

<p><strong>Step 2: Generate N-Entry Cycles</strong> (<code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">_correctPermutation()</code>)</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>// permutation.ts:368-418
private _correctPermutation() {
  let permutationFile = [];

<p>  for (const _group of this.permGroup) {<br>    const group = [..._group.keys()];  // Array of wire IDs<br>    const groupLength = group.length;  // N = number of wires sharing same value</p>

<p>    if (groupLength &gt; 1) {<br>      // Create N-entry cycles: Wire1 → Wire2 → ... → WireN → Wire1<br>      for (let i = 0; i &lt; groupLength; i++) {<br>        const element = JSON.parse(group[i]);<br>        const nextElement = JSON.parse(group[(i + 1) % groupLength]);  // Cycle!</p>

<p>        permutationFile.push({<br>          row: element.globalWireId - setupParams.l,<br>          col: element.placementId,<br>          X: nextElement.globalWireId - setupParams.l,<br>          Y: nextElement.placementId,<br>        });<br>      }<br>    }<br>  }</p>

<p>  return permutationFile;  // N-entry cycles written to JSON<br>}<br></code></pre></p>

<p><strong>Key Points</strong>:</p>

<p><li><strong>Parent-Child Tracking</strong>: During Phase 3 execution, each <a href="synthesizer-terminology.md#datapt-data-point">DataPt</a> stores its parent via <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">source</code> and <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">wireIndex</code> fields</li><br><li><strong>Grouping</strong>: <a href="synthesizer-terminology.md#wire">Wires</a> with the same value (parent and all children) are grouped together</li><br><li><strong>Cycle Size</strong>: <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">groupLength</code> determines the number of entries (2, 3, 4, ... N)</li><br><li><strong>Cycle Generation</strong>: <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">(i + 1) % groupLength</code> creates the circular structure (last → first)</li></p>

<p><strong>Why N-Entry Cycles?</strong></p>

<p>The cycle structure is required by the Tokamak zk-SNARK proof system to enforce <strong>wire equality constraints</strong>. Each cycle creates a constraint that all N wire positions in the cycle must have the same value, ensuring correct connections between <a href="synthesizer-terminology.md#placement">placements</a>.</p>

<p>---</p>

<h2>2. instance.json</h2>

<h3>Purpose</h3>

<p>Contains <strong>input/output values</strong> for the circuit, divided into public and private data. This is the "<a href="synthesizer-terminology.md#witness">witness</a>" for the circuit's I/O boundaries.</p>

<h3>Structure</h3>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>{
  &quot;publicOutputBuffer&quot;: {
    &quot;name&quot;: &quot;bufferPubOut&quot;,
    &quot;usage&quot;: &quot;Buffer to emit public circuit outputs&quot;,
    &quot;subcircuitId&quot;: 0,
    &quot;inPts&quot;: [
      {
        &quot;source&quot;: 30,
        &quot;wireIndex&quot;: 0,
        &quot;sourceSize&quot;: 32,
        &quot;valueHex&quot;: &quot;0xf805dd4619f94a449a4a798155a05a56&quot;
      },
      // ... more wires
    ],
    &quot;outPts&quot;: [...]
  },
  &quot;publicInputBuffer&quot;: { ... },
  &quot;privateOutputBuffer&quot;: { ... },
  &quot;privateInputBuffer&quot;: { ... },
  &quot;a_pub&quot;: [...],
  &quot;a_prv&quot;: [...]
}
</code></pre>

<h3>Reading the Format</h3>

<p><strong><a href="synthesizer-terminology.md#buffer-placements">Buffer</a> Sections</strong>:</p>

<p>1. <strong>publicInputBuffer</strong> (<a href="synthesizer-terminology.md#placement">Placement</a> 0 / <a href="synthesizer-terminology.md#pub-in-and-pub-out">PUB_IN</a>):</p>

<p>   - <strong>Purpose</strong>: External data that is publicly revealed and brought INTO the circuit<br>   - <strong>Examples</strong>: calldata, block.number, msg.sender, Keccak hash <strong>outputs</strong> (results computed externally and fed back into circuit)<br>   - <strong>Used by</strong>: Both Prover and Verifier</p>

<p>2. <strong>publicOutputBuffer</strong> (Placement 1 / <a href="synthesizer-terminology.md#pub-in-and-pub-out">PUB_OUT</a>):</p>

<p>   - <strong>Purpose</strong>: Circuit data that is sent OUT to be processed externally<br>   - <strong>Examples</strong>: return data, event logs, Keccak hash <strong>inputs</strong> (data to be hashed externally)<br>   - <strong>Used by</strong>: Both Prover and Verifier<br>   - <strong>Why Keccak inputs are outputs</strong>: Keccak256 is computed outside the circuit for efficiency. The circuit sends the data to hash (PUB_OUT), external system computes the hash, and the result comes back (PUB_IN)</p>

<p>3. <strong>privateInputBuffer</strong> (Placement 2 / <a href="synthesizer-terminology.md#prv-in-and-prv-out">PRV_IN</a>):</p>

<p>   - <strong>Purpose</strong>: External data that remains hidden<br>   - <strong>Examples</strong>: storage values, account state, bytecode constants<br>   - <strong>Used by</strong>: Prover only</p>

<p>4. <strong>privateOutputBuffer</strong> (Placement 3 / <a href="synthesizer-terminology.md#prv-in-and-prv-out">PRV_OUT</a>):<br>   - <strong>Purpose</strong>: Circuit outputs that remain hidden<br>   - <strong>Examples</strong>: storage updates, internal state changes<br>   - <strong>Used by</strong>: Prover only</p>

<p><strong><a href="synthesizer-terminology.md#wire">Wire</a> Format</strong>:</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>{
  &quot;source&quot;: 30,        // Placement ID that produced this value
  &quot;wireIndex&quot;: 0,      // Wire number within that placement
  &quot;sourceSize&quot;: 32,    // Size in bytes (usually 32 for 256-bit EVM words)
  &quot;valueHex&quot;: &quot;0x...&quot;  // Actual value in hexadecimal
}
</code></pre>

<p><strong><a href="synthesizer-terminology.md#witness">Witness</a> Arrays</strong>:</p>

<p><li><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">a_pub</code>: Complete public witness (all public intermediate values)</li><br><li><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">a_prv</code>: Complete private witness (all private intermediate values)</li></p>

<p>These arrays flatten all placement variables into sequential format for the prover.</p>

<h3>Example: SLOAD Operation</h3>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>// Storage value loaded from blockchain
{
  &quot;privateInputBuffer&quot;: {
    &quot;inPts&quot;: [
      {
        &quot;source&quot;: 2,           // PRV_IN buffer itself
        &quot;wireIndex&quot;: 104,      // 104th wire in PRV_IN
        &quot;sourceSize&quot;: 32,
        &quot;valueHex&quot;: &quot;0x64&quot;     // storage[key] = 100
      }
    ]
  }
}
</code></pre>

<p>Interpretation:</p>

<p><li>Storage value <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">100</code> (0x64) was loaded via RPC</li><br><li>Entered circuit as wire 104 in PRV_IN buffer (Placement 2)</li><br><li>Remains private throughout proof (never revealed to verifier)</li></p>

<p>---</p>

<h2>3. placementVariables.json</h2>

<h3>Purpose</h3>

<p>Contains <strong>complete <a href="synthesizer-terminology.md#witness">witness</a></strong> for every <a href="synthesizer-terminology.md#placement">placement</a> (<a href="synthesizer-terminology.md#subcircuit">subcircuit</a> instance). This includes all internal variables needed to satisfy the subcircuit's <a href="synthesizer-terminology.md#r1cs-rank-1-constraint-system">R1CS</a> constraints.</p>

<h3>Structure</h3>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>[
  {
    &quot;subcircuitId&quot;: 1,
    &quot;variables&quot;: [
      &quot;0x01&quot;,    // Variable 0
      &quot;0x58b5bbeb7719f6739471b5cb1b119a0d&quot;,  // Variable 1
      &quot;0xe34ae175aa5b73392e7b87f4fefe45d6&quot;,  // Variable 2
      // ... all internal circuit variables
    ]
  },
  {
    &quot;subcircuitId&quot;: 0,
    &quot;variables&quot;: [...]
  }
]
</code></pre>

<h3>Reading the Format</h3>

<p><strong>Structure</strong>:</p>

<p><li>Array of placement records</li><br><li>Each record contains:</li><br>  - <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">subcircuitId</code>: Which <a href="synthesizer-terminology.md#circom">Circom</a> subcircuit this placement uses<br>  - <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">variables</code>: All <a href="synthesizer-terminology.md#wire">wire</a> values for this placement instance</p>

<p><strong>Variable Ordering</strong>:</p>

<p>The <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">variables</code> array follows Circom's internal witness ordering:</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>variables[0]              = constant 1 (always 0x01)
variables[1..N_out]       = output signals
variables[N_out+1..N_out+N_in] = input signals
variables[N_out+N_in+1..] = internal signals
</code></pre>

<p><strong>Important</strong>: Outputs come <strong>before</strong> inputs in the witness array (Circom convention).</p>

<h3>Example: ALU1 Subcircuit</h3>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>template ALU1_() {
  signal input in[7];   // selector + 3x 256-bit inputs (2 limbs each)
  signal output out[4]; // 2x 256-bit outputs (2 limbs each)
  // ... internal signals
}
</code></pre>

<p><strong>Real Data Example</strong>:</p>

<pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>{
  &quot;subcircuitId&quot;: 4,
  &quot;variables&quot;: [
    &quot;0x01&quot;,      // [0] constant 1
    &quot;0x01&quot;,      // [1] out[0] - first output limb
    &quot;0x00&quot;,      // [2] out[1] - second output limb
    &quot;0x00&quot;,      // [3] out[2] - (unused)
    &quot;0x00&quot;,      // [4] out[3] - (unused)
    &quot;0x200000&quot;,  // [5] in[0] - selector (2^21 = ISZERO opcode)
    &quot;0x00&quot;,      // [6] in[1] - first input, lower limb
    &quot;0x00&quot;,      // [7] in[2] - first input, upper limb
    &quot;0x00&quot;,      // [8] in[3] - second input, lower limb
    &quot;0x00&quot;,      // [9] in[4] - second input, upper limb
    &quot;0x00&quot;,      // [10] in[5] - third input, lower limb
    &quot;0x00&quot;,      // [11] in[6] - third input, upper limb
    // [12+] hundreds of internal variables...
  ]
}
</code></pre>

<p>Interpretation:</p>

<p><li>Placement uses ALU1 subcircuit (ID 4)</li><br><li>Performs ISZERO operation (<a href="synthesizer-terminology.md#selector">selector</a> = 0x200000 = 2^21)</li><br>  - For selector value mappings, see <a href="synthesizer-opcodes.md#appendix-subcircuit-mapping-table">Appendix: Subcircuit Mapping Table</a><br><li>Input: 0x00 (256-bit zero, represented as two 0x00 <a href="synthesizer-terminology.md#limb">limbs</a>)</li><br>  - <strong>Why 2 limbs?</strong> Circom uses a 254-bit finite field, but Ethereum uses 256-bit numbers. To handle this, 256-bit values are split into two 128-bit limbs (lower and upper) to avoid field overflow.<br><li>Output: 0x01 (256-bit one, represented as 0x01 lower limb, 0x00 upper limb)</li><br><li>Logic: ISZERO(0) = 1 (true, input is zero)</li><br><li>Variables [12+] contain intermediate calculation steps (bitify, comparisons, etc.)</li></ul></p>

<h3>Subcircuit IDs</h3>

<p>Complete subcircuit list (from <a href="https://github.com/tokamak-network/Tokamak-zk-EVM/blob/main/packages/frontend/qap-compiler/subcircuits/library/subcircuitInfo.ts"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">qap-compiler/subcircuits/library/subcircuitInfo.ts</code></a>):</p>

<p>| ID  | Name         | Description                                                | Inputs | Outputs |<br>| --- | ------------ | ---------------------------------------------------------- | ------ | ------- |<br>| 0   | bufferPubOut | Public output buffer (RETURN data, event logs)             | 40     | 40      |<br>| 1   | bufferPubIn  | Public input buffer (calldata, tx data)                    | 20     | 20      |<br>| 2   | bufferPrvOut | Private output buffer (storage updates)                    | 40     | 40      |<br>| 3   | bufferPrvIn  | Private input buffer (storage values, bytecode)            | 512    | 512     |<br>| 4   | ALU1         | ADD, MUL, SUB, EQ, ISZERO, NOT, SubEXP                     | 7      | 4       |<br>| 5   | ALU2         | DIV, SDIV, MOD, SMOD, ADDMOD, MULMOD                       | 7      | 2       |<br>| 6   | ALU3         | SHL, SHR, SAR (bit shifts)                                 | 7      | 2       |<br>| 7   | ALU4         | LT, GT, SLT, SGT (comparisons)                             | 7      | 2       |<br>| 8   | ALU5         | SIGNEXTEND, BYTE                                           | 7      | 2       |<br>| 9   | OR           | Bitwise OR                                                 | 4      | 2       |<br>| 10  | XOR          | Bitwise XOR                                                | 4      | 2       |<br>| 11  | AND          | Bitwise AND                                                | 4      | 2       |<br>| 12  | DecToBit     | Number to bit array conversion (for memory operations)     | 2      | 256     |<br>| 13  | Accumulator  | Bit array to number conversion (for memory reconstruction) | 64     | 2       |<br></p>
  
  <hr style="margin-top: 60px; border: none; border-top: 1px solid #ddd;">
  <p style="color: #7f8c8d; font-size: 0.9em;">
    <em>이 문서는 <a href="https://YOUR-USERNAME.github.io/tokamak-zk-evm-docs">Tokamak zk-EVM Documentation</a>에서 변환되었습니다.</em>
  </p>
</body>
</html>