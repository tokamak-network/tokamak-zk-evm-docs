# Synthesizer: Output Files Reference

This document explains how to read and interpret the three output files generated by Synthesizer: `permutation.json`, `instance.json`, and `placementVariables.json`.

---

## Overview

After processing a transaction, Synthesizer generates three JSON files that contain all the information needed for proof generation:

| File                      | Purpose                              | Used By              | Size (typical)  |
| ------------------------- | ------------------------------------ | -------------------- | --------------- |
| `permutation.json`        | Circuit topology (wire connections)  | Setup, Prove, Verify | ~2-10 KB        |
| `instance.json`           | Public/private I/O witness           | Prove, Verify        | ~10-100 KB      |
| `placementVariables.json` | Complete witness for all subcircuits | Prove                | ~100 KB - 10 MB |

---

## 1. permutation.json

### Purpose

Describes **how wires are connected** between placements (subcircuit instances). This defines the circuit's topology as a Directed Acyclic Graph (DAG).

### Structure

```json
[
  {
    "row": 100,
    "col": 2,
    "X": 619,
    "Y": 26
  },
  {
    "row": 619,
    "col": 26,
    "X": 619,
    "Y": 27
  },
  {
    "row": 619,
    "col": 27,
    "X": 100,
    "Y": 2
  },
  // ... more entries
]
```

### Reading the Format

**Key Pattern**: Entries come in **3-entry cycles** representing one wire connection:

```
Entry 1: (row, col) → (X, Y)    // Source wire → Destination wire
Entry 2: (X, Y) → (X', Y')      // Intermediate connection
Entry 3: (X', Y') → (row, col)  // Cycle back to source
```

**Coordinate System**:

- `(row, col)` = Wire position in format `(wireIndex, placementId)`
- `row` = Wire index within a placement
- `col` = Placement ID (subcircuit instance number)

**Example Interpretation**:

```json
// Connection: Wire 100 from Placement 2 (PRV_IN) → Wire 619 in Placement 26
{ "row": 100, "col": 2, "X": 619, "Y": 26 },
{ "row": 619, "col": 26, "X": 619, "Y": 27 },
{ "row": 619, "col": 27, "X": 100, "Y": 2 }
```

Means:

1. **Placement 2** (PRV_IN buffer), **wire 100** outputs a value
2. This value connects to **Placement 26**, **wire 619** (input)
3. The cycle ensures wire equality: `PRV_IN[100] == Placement26[619]`

### Why 3-Entry Cycles?

The cycle structure is required by the Tokamak zk-SNARK proof system to enforce **wire equality constraints**. Each cycle creates a constraint that all three wire positions must have the same value, ensuring correct connections between placements.

### Common Patterns

**Buffer Connections** (Placement 0-3):

```json
// PRV_IN (Placement 2) → Some placement
{ "row": 104, "col": 2, "X": 616, "Y": 4 }
```

**Intermediate Connections** (Between subcircuits):

```json
// Output from Placement 617 → Input to Placement 619
{ "row": 617, "col": 13, "X": 619, "Y": 19 }
```

**Self-loops** (Within same placement):

```json
// Wire 616 in Placement 4 → Wire 616 in Placement 15
{ "row": 616, "col": 4, "X": 616, "Y": 15 }
```

---

## 2. instance.json

### Purpose

Contains **input/output values** for the circuit, divided into public and private data. This is the "witness" for the circuit's I/O boundaries.

### Structure

```json
{
  "publicOutputBuffer": {
    "name": "bufferPubOut",
    "usage": "Buffer to emit public circuit outputs",
    "subcircuitId": 0,
    "inPts": [
      {
        "source": 30,
        "wireIndex": 0,
        "sourceSize": 32,
        "valueHex": "0xf805dd4619f94a449a4a798155a05a56"
      },
      // ... more wires
    ],
    "outPts": [...]
  },
  "publicInputBuffer": { ... },
  "privateOutputBuffer": { ... },
  "privateInputBuffer": { ... },
  "a_pub": [...],
  "a_prv": [...]
}
```

### Reading the Format

**Buffer Sections**:

1. **publicInputBuffer** (Placement 0 / PUB_IN):

   - **Purpose**: External data that is publicly revealed
   - **Examples**: calldata, block.number, msg.sender, Keccak hash outputs
   - **Used by**: Verifier (public inputs to verify proof)

2. **publicOutputBuffer** (Placement 1 / PUB_OUT):

   - **Purpose**: Circuit outputs that are publicly revealed
   - **Examples**: return data, event logs, Keccak hash inputs
   - **Used by**: Verifier (public outputs to verify proof)

3. **privateInputBuffer** (Placement 2 / PRV_IN):

   - **Purpose**: External data that remains hidden
   - **Examples**: storage values, account state, bytecode constants
   - **Used by**: Prover only (never revealed to verifier)

4. **privateOutputBuffer** (Placement 3 / PRV_OUT):
   - **Purpose**: Circuit outputs that remain hidden
   - **Examples**: storage updates, internal state changes
   - **Used by**: Prover only

**Wire Format**:

```json
{
  "source": 30,        // Placement ID that produced this value
  "wireIndex": 0,      // Wire number within that placement
  "sourceSize": 32,    // Size in bytes (usually 32 for 256-bit EVM words)
  "valueHex": "0x..."  // Actual value in hexadecimal
}
```

**Witness Arrays**:

- `a_pub`: Complete public witness (all public intermediate values)
- `a_prv`: Complete private witness (all private intermediate values)

These arrays flatten all placement variables into sequential format for the prover.

### Example: SLOAD Operation

```json
// Storage value loaded from blockchain
{
  "privateInputBuffer": {
    "inPts": [
      {
        "source": 2,           // PRV_IN buffer itself
        "wireIndex": 104,      // 104th wire in PRV_IN
        "sourceSize": 32,
        "valueHex": "0x64"     // storage[key] = 100
      }
    ]
  }
}
```

Interpretation:

- Storage value `100` (0x64) was loaded via RPC
- Entered circuit as wire 104 in PRV_IN buffer (Placement 2)
- Remains private throughout proof (never revealed to verifier)

---

## 3. placementVariables.json

### Purpose

Contains **complete witness** for every placement (subcircuit instance). This includes all internal variables needed to satisfy the subcircuit's R1CS constraints.

### Structure

```json
[
  {
    "subcircuitId": 1,
    "variables": [
      "0x01",    // Variable 0
      "0x58b5bbeb7719f6739471b5cb1b119a0d",  // Variable 1
      "0xe34ae175aa5b73392e7b87f4fefe45d6",  // Variable 2
      // ... all internal circuit variables
    ]
  },
  {
    "subcircuitId": 0,
    "variables": [...]
  }
]
```

### Reading the Format

**Structure**:

- Array of placement records
- Each record contains:
  - `subcircuitId`: Which Circom subcircuit this placement uses
  - `variables`: All wire values for this placement instance

**Variable Ordering**:

The order of `variables` array matches the Circom subcircuit's signal order:

```circom
// Example: ALU1 subcircuit
template ALU1() {
  signal input selector;    // variables[0]
  signal input a;           // variables[1]
  signal input b;           // variables[2]
  signal output result;     // variables[3]
  // ... internal signals  // variables[4+]
}
```

### Example: ADD Operation

```json
{
  "subcircuitId": 4,  // ALU1 subcircuit
  "variables": [
    "0x02",    // selector = ADD (0x02)
    "0x0a",    // input a = 10
    "0x14",    // input b = 20
    "0x1e",    // output = 30
    // ... internal calculation variables
  ]
}
```

Interpretation:

- Placement uses ALU1 subcircuit (ID 4)
- Performs ADD operation (selector = 2)
- Inputs: 10 + 20
- Output: 30
- Remaining variables are intermediate calculation steps

### Subcircuit IDs

Common subcircuit IDs (from `qap-compiler`):

| ID  | Name         | Description             |
| --- | ------------ | ----------------------- |
| 0   | Buffer       | LOAD/RETURN buffers     |
| 1   | PubHash      | Keccak256 (external)    |
| 4   | ALU1         | ADD, SUB, MUL, DIV, MOD |
| 5   | ALU2         | ADDMOD, MULMOD          |
| 6   | ALU3         | EXP components          |
| 7   | SHR, SHL     | Bit shifts              |
| 8   | AND, OR, XOR | Bitwise operations      |
| 9   | Comparators  | LT, GT, EQ              |
| ... | ...          | ...                     |

---

## How Files Work Together

### 1. Circuit Topology (`permutation.json`)

Defines **structure**: Which placements exist and how they connect.

```
Placement 2 (PRV_IN) → Placement 4 (ALU1) → Placement 1 (PUB_OUT)
```

### 2. I/O Witness (`instance.json`)

Provides **boundary values**: Inputs and outputs at circuit edges.

```
PRV_IN[100] = 10
PRV_IN[101] = 20
PUB_OUT[0] = 30
```

### 3. Complete Witness (`placementVariables.json`)

Fills in **internal values**: All intermediate calculations.

```
ALU1[selector] = ADD
ALU1[a] = 10
ALU1[b] = 20
ALU1[result] = 30
ALU1[intermediate_1] = ...
ALU1[intermediate_2] = ...
```

### Proof Generation Flow

```
1. Setup Phase (using permutation.json):
   - Build circuit structure
   - Generate QAP polynomials
   - Compute proving/verification keys

2. Prove Phase (using all three files):
   - Load circuit topology (permutation.json)
   - Load I/O witness (instance.json)
   - Load complete witness (placementVariables.json)
   - Verify all R1CS constraints satisfied
   - Generate zk-SNARK proof

3. Verify Phase (using permutation.json + instance.json public parts):
   - Load circuit structure
   - Load public inputs/outputs only
   - Verify proof against public data
```

---

## Practical Tips

### Debugging Circuit Issues

**Check permutation.json**:

- Count 3-entry cycles: `totalEntries / 3 = number of wire connections`
- Look for placement IDs 0-3: These are buffer connections
- Trace a specific wire: Find all entries with matching `(row, col)`

**Check instance.json**:

- Verify buffer sizes: `inPts.length` should match expected inputs
- Compare `valueHex` values: Ensure they match EVM execution results
- Check `source` fields: Should reference valid placement IDs

**Check placementVariables.json**:

- Count placements: Should match number of subcircuit instantiations
- Verify first variables: Often inputs/outputs (easier to validate)
- Look for `0x00` patterns: May indicate unused wires or padding

### Performance Analysis

**Circuit Complexity**:

```javascript
// Count total constraints
const totalPlacements = placementVariables.length;
const avgConstraintsPerPlacement = 1000; // Varies by subcircuit
const estimatedConstraints = totalPlacements * avgConstraintsPerPlacement;
```

**Memory Usage**:

```javascript
// Estimate proving memory
const witnessSize = placementVariables.reduce((sum, p) =>
  sum + p.variables.length, 0
);
const estimatedMemory = witnessSize * 32; // bytes
```

---

## Related Documentation

- **[Transaction Flow](./synthesizer-transaction-flow.md)** - How these files are generated
- **[Code Examples](./synthesizer-code-examples.md)** - Specific operation examples
- **[Data Structures](./synthesizer-data-structure.md)** - DataPt, Placement types

---

## Further Reading

- **QAP Compiler**: Subcircuit library that defines subcircuit IDs and structures
- **Backend Prover**: Rust implementation that consumes these files for proof generation
- **Tokamak zk-SNARK Paper**: [https://eprint.iacr.org/2024/507](https://eprint.iacr.org/2024/507)
